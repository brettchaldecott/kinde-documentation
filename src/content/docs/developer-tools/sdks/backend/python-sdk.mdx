---
page_id: 2b425ccb-d328-41ff-afb2-016019f46839
title: Python SDK
sidebar:
  order: 15
head:
  - tag: meta
    attrs:
      property: "og:image"
      content: "https://kinde.com/assets/images/open-graph/DOCS-SSI-SDK_python.png"
---

The Kinde Python SDK allows developers to quickly and securely integrate a new or an existing Python application into the Kinde platform. The SDK supports both Flask and FastAPI frameworks through a single unified interface.

## Before you begin

- Kinde Python SDK supports Python 3.9+
- If you haven't already got a Kinde account, [register for free here](https://app.kinde.com/register) (no credit card required). Registering gives you a Kinde domain, which you need to get started, e.g. `yourapp.kinde.com`.

If you are using a previous version of Python, you may need to refer to the [previous v1 SDK](/developer-tools/sdks/backend/python-sdk-v1/).

If you're migrating from an older version of the SDK, see our [migration guide](https://github.com/kinde-oss/kinde-python-sdk/blob/main/MIGRATION.md) for detailed instructions.

For new projects, you can find our [Starter Kit on GitHub](https://github.com/kinde-starter-kits/python-starter-kit).

## Install

Install [PIP](https://pip.pypa.io/en/stable/installation/) and then execute the following command:

```bash
pip install kinde-python-sdk
```

### Environment variables

The Kinde Python SDK uses environment variables for configuration. Here are all the supported variables:

#### Required variables
- `KINDE_CLIENT_ID` - Your application's client ID from Kinde
- `KINDE_CLIENT_SECRET` - Your application's client secret from Kinde
- `KINDE_REDIRECT_URI` - The callback URL where Kinde will redirect after authentication
- `KINDE_HOST` - Your Kinde domain (e.g., `https://yourdomain.kinde.com`)
- `KINDE_ISSUER_URL` - Your Kinde issuer URL (typically same as KINDE_HOST)
- `GRANT_TYPE` - The OAuth grant type to use (e.g., `AUTHORIZATION_CODE_WITH_PKCE`)

#### Optional variables
- `KINDE_AUDIENCE` - The intended recipient of the access token (for API access)
- `KINDE_CALLBACK_URL` - Alternative name for KINDE_REDIRECT_URI
- `LOGOUT_REDIRECT_URL` - Where users are redirected after logout
- `SITE_HOST` - Your application's host (default: `127.0.0.1`)
- `SITE_PORT` - Your application's port (default: `5000`)
- `SITE_URL` - Your application's base URL
- `CODE_VERIFIER` - Required for PKCE flow (auto-generated if not provided)

**Session management variables** (core SDK features):
- `SECRET_KEY` - Used for session management and token security
- `SESSION_TYPE` - Session storage type (e.g., `filesystem`)
- `SESSION_PERMANENT` - Whether sessions are permanent (default: `False`)

**Application configuration**:
- `TEMPLATES_AUTO_RELOAD` - Whether to auto-reload templates (default: `True`)

**Management API variables** (only needed if using Management API features):
- `MGMT_API_CLIENT_ID` - Management API client ID
- `MGMT_API_CLIENT_SECRET` - Management API client secret

Example `.env` file:
```bash
KINDE_CLIENT_ID=your_client_id
KINDE_CLIENT_SECRET=your_client_secret
KINDE_REDIRECT_URI=http://localhost:5000/api/auth/kinde_callback
KINDE_HOST=https://yourdomain.kinde.com
KINDE_ISSUER_URL=https://yourdomain.kinde.com
GRANT_TYPE=AUTHORIZATION_CODE_WITH_PKCE
SITE_HOST=localhost
SITE_PORT=5000
SITE_URL=http://localhost:5000
LOGOUT_REDIRECT_URL=http://localhost:8000
SECRET_KEY=your_secret_key
SESSION_TYPE=filesystem
SESSION_PERMANENT=False
TEMPLATES_AUTO_RELOAD=True
```

### Set callback URLs

1. In Kinde, go to **Settings > Applications > [Your app] > View details**.
2. Add your callback URLs in the relevant fields. For example:
   - Allowed callback URLs (also known as redirect URIs) - for example, `http://localhost:8000/callback`
   - Allowed logout redirect URLs - for example, `http://localhost:8000`
3. Select **Save**.

### Add environments

Kinde comes with a production environment, but you can set up other environments if you want to. Note that each environment needs to be set up independently, so you need to use the Environment subdomain in the code block above for those new environments.

## Configure your app

The OAuth client is now automatically configured based on the framework you're using. Simply import the OAuth class from the auth module and create an instance:

```python
from kinde_sdk.auth.oauth import OAuth

# For Flask applications
from flask import Flask
app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app  # optional: pass your Flask app instance
)

# For FastAPI applications
from fastapi import FastAPI
app = FastAPI()
oauth = OAuth(
    framework="fastapi",
    app=app  # optional: pass your FastAPI app instance
)
```

The SDK will automatically detect and configure the appropriate framework implementation based on the framework parameter and app instance you provide.

## Sign in and sign up

The Kinde client provides methods for easy sign in and sign up. You can add buttons in your HTML as follows:

```html
<div class="navigation">
  <a href="{{ url_for('login') }}" type="button">Sign in</a>
  <a href="{{ url_for('register') }}" type="button">Sign up</a>
</div>
```

### Automatic Route Registration

The framework wrapper can automatically register all necessary routes. For Flask:

```python
from kinde_sdk.auth.oauth import OAuth
from flask import Flask

app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app
)
```

For FastAPI:

```python
from kinde_sdk.auth.oauth import OAuth
from fastapi import FastAPI

app = FastAPI()
oauth = OAuth(
    framework="fastapi",
    app=app
)
```

### Manual route implementation

If you prefer to implement the routes manually, here's how you can do it:

For Flask:

```python
import asyncio
from flask import Flask, request, session, redirect
from kinde_sdk.auth.oauth import OAuth

app = Flask(__name__)
oauth = OAuth(
    framework="flask",
    app=app
)

@app.route('/login')
def login():
    """Redirect to Kinde login page."""
    loop = asyncio.get_event_loop()
    login_url = loop.run_until_complete(oauth.login())
    return redirect(login_url)

@app.route('/register')
def register():
    """Redirect to Kinde registration page."""
    loop = asyncio.get_event_loop()
    register_url = loop.run_until_complete(oauth.register())
    return redirect(register_url)

@app.route('/callback')
def callback():
    """Handle the OAuth callback from Kinde."""
    try:
        code = request.args.get('code')
        state = request.args.get('state')
        
        if not code:
            return "Authentication failed: No code provided", 400
        
        # Generate a unique user ID for the session
        user_id = session.get('user_id') or str(uuid.uuid4())
        
        # Use OAuth's handle_redirect method to process the callback
        loop = asyncio.get_event_loop()
        result = loop.run_until_complete(oauth.handle_redirect(code, user_id, state))
        
        # Store user ID in session
        session['user_id'] = user_id
        
        return redirect('/')
    except Exception as e:
        return f"Authentication failed: {str(e)}", 400

@app.route('/logout')
def logout():
    """Logout the user and redirect to Kinde logout page."""
    user_id = session.get('user_id')
    session.clear()
    loop = asyncio.get_event_loop()
    logout_url = loop.run_until_complete(oauth.logout(user_id))
    return redirect(logout_url)

@app.route('/user')
def get_user():
    """Get the current user's information."""
    try:
        if not oauth.is_authenticated(request):
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                login_url = loop.run_until_complete(oauth.login())
                return redirect(login_url)
            finally:
                loop.close()
        
        return oauth.get_user_info(request)
    except Exception as e:
        return f"Failed to get user info: {str(e)}", 400
```

For FastAPI:

```python
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse

@app.get("/login")
async def login(request: Request):
    url = await oauth.login()
    return RedirectResponse(url=url)

@app.get("/register")
async def register(request: Request):
    url = await oauth.register()
    return RedirectResponse(url=url)

@app.get("/callback")
async def callback(request: Request, code: str, state: Optional[str] = None):
    try:
        result = await oauth.handle_redirect(code, state)
        return RedirectResponse(url="/")
    except Exception as e:
        return HTMLResponse(f"Authentication failed: {str(e)}")

@app.get("/logout")
async def logout(request: Request):
    request.session.clear()
    return RedirectResponse(url=await oauth.logout())

@app.get("/user")
async def get_user(request: Request):
    if not oauth.is_authenticated(request):
        return RedirectResponse(url=await oauth.login())
    return oauth.get_user_info(request)
```

The manual implementation gives you more control over the authentication flow and allows you to add custom logic like session management, error handling, and logging. Note that Flask requires special handling of async methods using `asyncio` since it doesn't natively support async/await like FastAPI does.

## User permissions

The Kinde Python SDK provides a simple way to check user permissions in your application. First, import the permissions module:

```python
from kinde_sdk.auth import permissions
```

### Checking permissions

To check if a user has a specific permission:

```python
# Check a single permission
permission = await permissions.get_permission("create:todos")
if permission["isGranted"]:
    # User has permission
    print(f"User has permission in organization: {permission['orgCode']}")
```

To get all permissions for the current user:

```python
# Get all permissions
all_permissions = await permissions.get_permissions()
print(f"User belongs to organization: {all_permissions['orgCode']}")
print("User permissions:", all_permissions["permissions"])
```

### Practical examples

Here's how to use permissions in your application:

```python
# Example 1: Conditional Feature Access
async def create_todo_button():
    permission = await permissions.get_permission("create:todos")
    if permission["isGranted"]:
        return "<button>Create Todo</button>"
    return None

# Example 2: Permission-Based API Endpoint
@router.post("/todos")
async def create_todo(todo_data: dict):
    permission = await permissions.get_permission("create:todos")
    if not permission["isGranted"]:
        raise HTTPException(status_code=403, detail="Permission denied")
    # Create todo logic here...
```

### Common permission patterns

Here are some common permission patterns you might use:

```python
# Resource-based permissions
"create:todos"
"read:todos"
"update:todos"
"delete:todos"

# Feature-based permissions
"can:export_data"
"can:manage_users"
"can:view_analytics"

# Organization-based permissions
"org:manage_members"
"org:view_billing"
"org:update_settings"
```

For more information about setting up permissions in Kinde, see [User permissions](/manage-users/roles-and-permissions/user-permissions/).

## Feature flags

The Kinde Python SDK provides a simple way to access feature flags from your application. First, import the feature flags module:

```python
from kinde_sdk.auth import feature_flags
```

### Getting feature flags

To get a specific feature flag value:

```python
# Get a string feature flag
theme_flag = await feature_flags.get_flag("theme")
print(f"Current theme: {theme_flag.value}")

# Get a boolean feature flag with default value
dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False)
if dark_mode.value:
    print("Dark mode is enabled")

# Get a numeric feature flag
competitions_limit = await feature_flags.get_flag("competitions_limit")
print(f"User can create up to {competitions_limit.value} competitions")
```

To get all feature flags for the current user:

```python
# Get all feature flags
all_flags = await feature_flags.get_all_flags()
for code, flag in all_flags.items():
    print(f"- {code}: {flag.value} ({flag.type})")
```

### Practical examples

Here's how to use feature flags in your application:

```python
# Example 1: Conditional Feature Rendering
async def render_create_competition_button():
    can_create = await feature_flags.get_flag("create_competition", default_value=False)
    if can_create.value:
        return "<button>Create Competition</button>"
    return None

# Example 2: Theme Configuration
async def get_user_theme():
    theme = await feature_flags.get_flag("theme", default_value="light")
    dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False)
    return {
        "theme": theme.value,
        "is_dark_mode": dark_mode.value
    }

# Example 3: Feature Limits
@router.post("/competitions")
async def create_competition(competition_data: dict):
    limit_flag = await feature_flags.get_flag("competitions_limit", default_value=3)
    current_count = await get_user_competition_count()
    
    if current_count >= limit_flag.value:
        raise HTTPException(
            status_code=403,
            detail=f"Competition limit reached (max: {limit_flag.value})"
        )
    # Create competition logic here...
```

### Feature flag types

The SDK supports the following feature flag types:

```python
# String flags
{
    "t": "s",
    "v": "pink"
}

# Boolean flags
{
    "t": "b",
    "v": true
}

# Integer flags
{
    "t": "i",
    "v": 5
}
```

### Common use cases

```python
# Feature Toggles
can_use_feature = await feature_flags.get_flag("enable_new_feature", default_value=False)

# User Preferences
theme = await feature_flags.get_flag("theme", default_value="light")
dark_mode = await feature_flags.get_flag("is_dark_mode", default_value=False)

# Usage Limits
max_uploads = await feature_flags.get_flag("max_uploads", default_value=10)

# A/B Testing
test_group = await feature_flags.get_flag("ab_test_group", default_value="control")
```

## Claims

The Kinde Python SDK provides a simple way to access user claims from your application. First, import the claims module:

```python
from kinde_sdk.auth import claims
```

### Getting claims

To get a specific claim from the user's tokens:

```python
# Get the audience claim from the access token
claim = await claims.get_claim("aud")
print(f"Token audience: {claim['value']}")

# Get the given_name claim from the ID token
claim = await claims.get_claim("given_name", token_type="id_token")
print(f"User's given name: {claim['value']}")
```

To get all claims from the user's tokens:

```python
# Get all claims from the access token
all_claims = await claims.get_all_claims()
for claim_name, claim_value in all_claims.items():
    print(f"- {claim_name}: {claim_value}")

# Get all claims from the ID token
id_token_claims = await claims.get_all_claims(token_type="id_token")
```

### Practical examples

Here's how to use claims in your application:

```python
# Example 1: Accessing User Information
async def get_user_profile():
    given_name = await claims.get_claim("given_name", token_type="id_token")
    family_name = await claims.get_claim("family_name", token_type="id_token")
    
    if given_name["value"] and family_name["value"]:
        return {
            "name": f"{given_name['value']} {family_name['value']}",
            "email": (await claims.get_claim("email", token_type="id_token"))["value"]
        }
    return None

# Example 2: Token Validation
@router.get("/api/protected")
async def protected_endpoint():
    aud_claim = await claims.get_claim("aud")
    if not aud_claim["value"] or "api.yourapp.com" not in aud_claim["value"]:
        raise HTTPException(status_code=401, detail="Invalid token audience")
    return {"message": "Access granted"}
```

### Common claims

Here are some common claims you might want to access:

```python
# User Information (ID Token)
"given_name"
"family_name"
"email"
"picture"

# Token Information (Access Token)
"aud"           # Audience
"iss"           # Issuer
"exp"           # Expiration time
"iat"           # Issued at time

# Organization Information
"org_code"
"org_name"
"org_id"
```



## Organizations

### Create an organization

To create a new organization within your application, you will need to run a similar function to below:

```python
return app.redirect(oauth.create_org())
```

### Sign up and sign in to organizations

Kinde has a unique code for every organization. You'll have to pass this code through when you register a new user or sign in to a particular organization. Example function below:

```python
oauth.get_claim("org_code")

@app.route("/login")
def login():
    return app.redirect(oauth.get_login_url())


@app.route("/register")
def register():
    return app.redirect(oauth.get_register_url())
```

Following authentication, Kinde provides a json web token (jwt) to your application. Along with the standard information we also include the `org_code` and the permissions for that organization (this is important as a user can belong to multiple organizations and have different permissions for each).

Example of a returned token:

```python
{
   "aud": [],
   "exp": 1658475930,
   "iat": 1658472329,
   "iss": "https://your_subdomain.kinde.com",
   "jti": "123457890",
   "org_code": "org_1234",
   "permissions": ["read:todos", "create:todos"],
   "scp": [
		   "openid",
		   "profile",
		   "email",
		   "offline"
   ],
   "sub": "kp:123457890"
}
```

The `id_token` will also contain an array of organizations that a user belongs to - this is useful if you wanted to build out an organization switcher for example.

```python
{
		...
		"org_codes": ["org_1234", "org_4567"],
		...
};
```

There are two helper functions you can use to extract information:

```python
oauth.get_organization()

oauth.get_user_organizations()
```

For more information about how organizations work in Kinde, see [Kinde organizations for developers](/build/organizations/orgs-for-developers/).

### Token and session management

The Kinde Python SDK automatically handles token and session management for your application. Once a user has successfully authenticated, the SDK manages:

- **Token acquisition and storage**: Automatically obtains and securely stores access tokens, ID tokens, and refresh tokens
- **Token refresh**: Automatically refreshes tokens when they expire
- **Session management**: Handles user sessions across requests
- **Framework integration**: Works seamlessly with Flask and FastAPI session systems

The SDK uses the session configuration from your environment variables (`SECRET_KEY`, `SESSION_TYPE`, `SESSION_PERMANENT`) to manage sessions appropriately for your chosen framework.

#### Token types

The SDK supports two types of tokens:

1. **Access Token** (`token_type="access_token"`):
   - Contains authorization information
   - Used for API access
   - Contains permissions and organization context
   - Default token type

2. **ID Token** (`token_type="id_token"`):
   - Contains user identity information
   - Used for user profile data
   - Contains name, email, and other user details
   - Must be explicitly requested using `token_type="id_token"`

#### Session handling

The SDK automatically integrates with your framework's session system:

- **Flask**: Uses Flask's built-in session management
- **FastAPI**: Integrates with FastAPI's session handling

You don't need to manually manage tokens or sessions - the SDK handles this automatically for you.

## Management API

The Kinde Python SDK provides a Management API client for interacting with Kinde's management endpoints. This allows you to programmatically manage users, organizations, and other resources.

### Getting started

To use the Management API, you'll need to initialize the client with your Kinde credentials:

```python
from kinde_sdk.auth.oauth import OAuth

oauth = OAuth(
    framework="flask",
    app=app
)

# Get the management client
management = oauth.get_management()
```

### Available endpoints

The Management API provides methods for common operations on resources. Here are some examples:

```python
# List users
users = await management.get_users()

# Get a specific user
user = await management.get_user(user_id="user_123")

# Create a new user
new_user = await management.create_user(
    email="user@example.com",
    given_name="John",
    family_name="Doe"
)

# Update a user
updated_user = await management.update_user(
    user_id="user_123",
    given_name="Johnny"
)

# Delete a user
await management.delete_user(user_id="user_123")
```

### Organization management

```python
# List organizations
orgs = await management.get_organizations()

# Get a specific organization
org = await management.get_organization(org_id="org_123")

# Create a new organization
new_org = await management.create_organization(
    name="My Organization"
)

# Update an organization
updated_org = await management.update_organization(
    org_id="org_123",
    name="Updated Name"
)

# Delete an organization
await management.delete_organization(org_id="org_123")
```

### Error handling

The Management API methods will raise exceptions for API errors. It's recommended to handle these appropriately:

```python
try:
    user = await management.get_user(user_id="user_123")
except Exception as e:
    # Handle API-specific errors
    print(f"Error: {e}")
```

### Token management

The Management API client has its own token management system for API authentication, which is separate from the core SDK's user session token management. The Management API client automatically handles:

- **accessing Kinde Management API endpoints**: Obtains tokens for accessing Kinde's management endpoints
- **Token refresh**: Automatically refreshes management API tokens when they expire
- **Token storage**: Securely stores management API tokens
- **Thread safety**: Ensures thread-safe token handling for concurrent requests

You don't need to manually manage Management API tokens - the client handles this for you. This is different from the core SDK's user session token management, which handles user authentication tokens automatically.

### Best practices

1. Always use async/await when calling Management API methods
2. Handle API errors appropriately
3. Cache results when appropriate to reduce API calls
4. Use appropriate error handling for production environments
5. Keep your client credentials secure

For more information about the Management API endpoints and capabilities, see the [Kinde Management API documentation](https://docs.kinde.com/kinde-apis/management/).

## Machine-to-Machine (M2M) Applications

The Kinde Python SDK supports Machine-to-Machine (M2M) applications, which allow server-to-server communication without user interaction. M2M applications use client credentials flow and can validate bearer tokens for secure API access.

The implementation approach differs depending on your web framework. Below are examples for FastAPI, Flask, and Django.

### Environment setup for M2M

For M2M applications, you'll need additional environment variables:

```bash
# M2M Management API credentials
KINDE_MANAGEMENT_CLIENT_ID=your_m2m_client_id
KINDE_MANAGEMENT_CLIENT_SECRET=your_m2m_client_secret
```

## FastAPI M2M Implementation

FastAPI provides excellent support for M2M applications with built-in dependency injection and automatic request validation.

### Token validation and introspection with FastAPI

M2M applications can validate incoming bearer tokens using token introspection. Here's how to implement secure token validation with FastAPI:

```python
import os
import logging
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from kinde_sdk.auth.management import ManagementTokenManager, ManagementClient

# Set up logging
logger = logging.getLogger(__name__)
security = HTTPBearer()

# Extract, introspect, and validate management token from header
def get_management_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> ManagementTokenManager:
    logger.debug("Starting token validation")
    bearer_token = credentials.credentials
    logger.debug(f"Received bearer token (first 20 chars): {bearer_token[:20]}...")
    
    # SDK config from env
    domain = os.getenv("KINDE_HOST", "https://app.kinde.com")
    logger.debug(f"Raw domain from env: {domain}")
    if domain.startswith(('http://', 'https://')):
        domain = domain.split('://', 1)[1]
    logger.debug(f"Normalized domain: {domain}")
    client_id = os.getenv("KINDE_MANAGEMENT_CLIENT_ID")
    client_secret = os.getenv("KINDE_MANAGEMENT_CLIENT_SECRET")
    logger.debug(f"Client ID: {client_id}")
    # Not logging secret for security
    
    if not all([domain, client_id, client_secret]):
        logger.error("Missing Kinde management credentials")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Missing Kinde management credentials in environment"
        )
    
    try:
        token_manager = ManagementTokenManager(
            domain=domain,
            client_id=client_id,
            client_secret=client_secret
        )
        logger.debug(f"ManagementTokenManager instantiated {bearer_token}")
        
        introspection_result = token_manager.validate_and_set_via_introspection(bearer_token)
        logger.debug(f"Introspection result: {introspection_result}")
        
        access_token = token_manager.get_access_token()
        if not access_token:
            logger.error("No access token after introspection")
            raise ValueError("Invalid management token after introspection")
        logger.debug("Access token obtained successfully")
        
        return token_manager
    
    except ValueError as e:
        logger.error(f"ValueError in token validation: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"}
        )
    except Exception as e:
        logger.error(f"Exception in token validation: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Token introspection failed: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"}
        )
```

### FastAPI M2M API endpoints

Once you have token validation set up, you can create secure M2M API endpoints with FastAPI:

```python
from fastapi import FastAPI

app = FastAPI()

# Example route using the validated management token
@app.get("/management/users")
async def get_users(token_manager: ManagementTokenManager = Depends(get_management_token)):
    logger.debug("Entering get_users endpoint")
    try:
        # Create ManagementClient with the token manager
        management_client = ManagementClient(
            domain=token_manager.domain,
            client_id=token_manager.client_id,
            client_secret=token_manager.client_secret
        )
        logger.debug("ManagementClient created")
        
        # Fetch users (example API call)
        users_response = management_client.get_users()
        
        # Get the user count from the response
        user_count = len(users_response.users) if users_response.users else 0
        logger.debug(f"Fetched {user_count} users")
        
        return {
            "message": "Users fetched successfully",
            "user_count": user_count,
            "users": users_response.users if users_response.users else []  # In production, filter sensitive data
        }
    except Exception as e:
        logger.error(f"Error in get_users: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch users: {str(e)}"
        ) from e

# Example organization management endpoint
@app.get("/management/organizations")
async def get_organizations(token_manager: ManagementTokenManager = Depends(get_management_token)):
    try:
        management_client = ManagementClient(
            domain=token_manager.domain,
            client_id=token_manager.client_id,
            client_secret=token_manager.client_secret
        )
        
        orgs_response = management_client.get_organizations()
        
        return {
            "message": "Organizations fetched successfully",
            "organizations": orgs_response.organizations if orgs_response.organizations else []
        }
    except Exception as e:
        logger.error(f"Error in get_organizations: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch organizations: {str(e)}"
        ) from e
```

### Advanced FastAPI M2M patterns

Here are some advanced patterns for M2M applications with FastAPI:

```python
# Custom token validation with additional checks
def validate_token_with_scopes(required_scopes: list):
    def _validate_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> ManagementTokenManager:
        token_manager = get_management_token(credentials)
        
        # Check if token has required scopes
        token_scopes = token_manager.get_token_scopes()
        missing_scopes = [scope for scope in required_scopes if scope not in token_scopes]
        
        if missing_scopes:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required scopes: {missing_scopes}"
            )
        
        return token_manager
    
    return _validate_token

# Endpoint with scope validation
@app.get("/management/sensitive-data")
async def get_sensitive_data(
    token_manager: ManagementTokenManager = Depends(validate_token_with_scopes(["read:sensitive_data"]))
):
    # Your sensitive data logic here
    return {"data": "sensitive information"}

# Rate limiting with token validation
from fastapi import Request
import time

# Simple in-memory rate limiter (use Redis in production)
request_counts = {}

def rate_limit_by_token(max_requests: int = 100, window_seconds: int = 60):
    def _rate_limit(request: Request, token_manager: ManagementTokenManager = Depends(get_management_token)):
        client_id = token_manager.client_id
        current_time = time.time()
        
        if client_id not in request_counts:
            request_counts[client_id] = {"count": 0, "window_start": current_time}
        
        # Reset window if needed
        if current_time - request_counts[client_id]["window_start"] > window_seconds:
            request_counts[client_id] = {"count": 1, "window_start": current_time}
        else:
            request_counts[client_id]["count"] += 1
            
            if request_counts[client_id]["count"] > max_requests:
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail="Rate limit exceeded"
                )
        
        return token_manager
    
    return _rate_limit

# Rate-limited endpoint
@app.get("/management/users/limited")
async def get_users_limited(
    token_manager: ManagementTokenManager = Depends(rate_limit_by_token(max_requests=50))
):
    # Your rate-limited logic here
    return {"message": "Rate-limited user data"}
```

### Error handling for FastAPI M2M

FastAPI provides excellent exception handling capabilities:

```python
from fastapi import HTTPException, status
from typing import Optional

# Custom exceptions for M2M operations
class M2MAuthenticationError(Exception):
    """Raised when M2M authentication fails"""
    pass

class M2MAuthorizationError(Exception):
    """Raised when M2M authorization fails"""
    pass

class M2MValidationError(Exception):
    """Raised when M2M request validation fails"""
    pass

# Simple error handling in endpoints
@app.get("/management/users/secure")
async def get_users_secure(token_manager: ManagementTokenManager = Depends(get_management_token)):
    try:
        management_client = ManagementClient(
            domain=token_manager.domain,
            client_id=token_manager.client_id,
            client_secret=token_manager.client_secret
        )
        
        users_response = management_client.get_users()
        return {"users": users_response.users}
        
    except M2MAuthenticationError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed",
            headers={"WWW-Authenticate": "Bearer"}
        )
    except M2MAuthorizationError:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    except M2MValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        # Log the actual error for debugging
        logger.error(f"Unexpected error in get_users: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )

# Alternative: Using FastAPI's exception handlers
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(M2MAuthenticationError)
async def m2m_auth_exception_handler(request: Request, exc: M2MAuthenticationError):
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={"detail": "Authentication failed"},
        headers={"WWW-Authenticate": "Bearer"}
    )

@app.exception_handler(M2MAuthorizationError)
async def m2m_authz_exception_handler(request: Request, exc: M2MAuthorizationError):
    return JSONResponse(
        status_code=status.HTTP_403_FORBIDDEN,
        content={"detail": "Insufficient permissions"}
    )

@app.exception_handler(M2MValidationError)
async def m2m_validation_exception_handler(request: Request, exc: M2MValidationError):
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={"detail": str(exc)}
    )

# With exception handlers, your endpoints become much cleaner
@app.get("/management/users/clean")
async def get_users_clean(token_manager: ManagementTokenManager = Depends(get_management_token)):
    management_client = ManagementClient(
        domain=token_manager.domain,
        client_id=token_manager.client_id,
        client_secret=token_manager.client_secret
    )
    
    users_response = management_client.get_users()
    return {"users": users_response.users}
    # Custom exceptions will be automatically handled by the exception handlers
```

### Security best practices for M2M

1. **Token Validation**: Always validate incoming bearer tokens using introspection
2. **Scope Checking**: Verify that tokens have the required scopes for each operation
3. **Rate Limiting**: Implement rate limiting to prevent abuse
4. **Logging**: Log all M2M operations for audit trails
5. **Error Handling**: Use proper HTTP status codes and error messages
6. **Credential Security**: Store client credentials securely and never log them
7. **Token Expiration**: Handle token expiration gracefully
8. **HTTPS Only**: Always use HTTPS in production

### Testing FastAPI M2M endpoints

Here's how to test your FastAPI M2M endpoints:

```python
import requests

# Test token validation
def test_m2m_endpoint():
    url = "https://your-api.com/management/users"
    headers = {
        "Authorization": "Bearer your_valid_token_here"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        print("M2M endpoint working correctly")
        print(f"Response: {response.json()}")
    else:
        print(f"Error: {response.status_code}")
        print(f"Response: {response.text}")

# Test with invalid token
def test_invalid_token():
    url = "https://your-api.com/management/users"
    headers = {
        "Authorization": "Bearer invalid_token"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 401:
        print("Token validation working correctly")
    else:
        print("Token validation not working as expected")
```

## Flask M2M Implementation

Flask requires a different approach since it doesn't have built-in dependency injection like FastAPI. Here's how to implement M2M functionality with Flask:

### Token validation with Flask

```python
import os
import logging
from flask import Flask, request, jsonify, g
from functools import wraps
from kinde_sdk.auth.management import ManagementTokenManager, ManagementClient

# Set up logging
logger = logging.getLogger(__name__)

app = Flask(__name__)

def get_management_token_flask():
    """Extract and validate management token from Flask request"""
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        raise ValueError("Missing or invalid Authorization header")
    
    bearer_token = auth_header.split(' ')[1]
    logger.debug(f"Received bearer token (first 20 chars): {bearer_token[:20]}...")
    
    # SDK config from env
    domain = os.getenv("KINDE_HOST", "https://app.kinde.com")
    if domain.startswith(('http://', 'https://')):
        domain = domain.split('://', 1)[1]
    
    client_id = os.getenv("KINDE_MANAGEMENT_CLIENT_ID")
    client_secret = os.getenv("KINDE_MANAGEMENT_CLIENT_SECRET")
    
    if not all([domain, client_id, client_secret]):
        raise ValueError("Missing Kinde management credentials in environment")
    
    try:
        token_manager = ManagementTokenManager(
            domain=domain,
            client_id=client_id,
            client_secret=client_secret
        )
        
        introspection_result = token_manager.validate_and_set_via_introspection(bearer_token)
        logger.debug(f"Introspection result: {introspection_result}")
        
        access_token = token_manager.get_access_token()
        if not access_token:
            raise ValueError("Invalid management token after introspection")
        
        return token_manager
    
    except Exception as e:
        logger.error(f"Token validation failed: {str(e)}")
        raise ValueError(f"Token introspection failed: {str(e)}")

def require_m2m_auth(f):
    """Decorator to require M2M authentication for Flask routes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            token_manager = get_management_token_flask()
            # Store token_manager in Flask's g object for use in route
            g.token_manager = token_manager
            return f(*args, **kwargs)
        except ValueError as e:
            return jsonify({"error": str(e)}), 401
        except Exception as e:
            logger.error(f"Authentication error: {str(e)}")
            return jsonify({"error": "Authentication failed"}), 401
    return decorated_function
```

### Flask M2M API endpoints

```python
@app.route('/management/users', methods=['GET'])
@require_m2m_auth
def get_users():
    """Get users with M2M authentication"""
    try:
        token_manager = g.token_manager
        
        # Create ManagementClient with the token manager
        management_client = ManagementClient(
            domain=token_manager.domain,
            client_id=token_manager.client_id,
            client_secret=token_manager.client_secret
        )
        
        # Fetch users
        users_response = management_client.get_users()
        user_count = len(users_response.users) if users_response.users else 0
        
        return jsonify({
            "message": "Users fetched successfully",
            "user_count": user_count,
            "users": users_response.users if users_response.users else []
        })
    except Exception as e:
        logger.error(f"Error in get_users: {str(e)}")
        return jsonify({"error": f"Failed to fetch users: {str(e)}"}), 500

@app.route('/management/organizations', methods=['GET'])
@require_m2m_auth
def get_organizations():
    """Get organizations with M2M authentication"""
    try:
        token_manager = g.token_manager
        
        management_client = ManagementClient(
            domain=token_manager.domain,
            client_id=token_manager.client_id,
            client_secret=token_manager.client_secret
        )
        
        orgs_response = management_client.get_organizations()
        
        return jsonify({
            "message": "Organizations fetched successfully",
            "organizations": orgs_response.organizations if orgs_response.organizations else []
        })
    except Exception as e:
        logger.error(f"Error in get_organizations: {str(e)}")
        return jsonify({"error": f"Failed to fetch organizations: {str(e)}"}), 500
```

## Django M2M Implementation

Django provides middleware-based authentication. Here's how to implement M2M functionality with Django:

### Token validation with Django

```python
import os
import logging
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.views import View
from functools import wraps
from kinde_sdk.auth.management import ManagementTokenManager, ManagementClient

logger = logging.getLogger(__name__)

def get_management_token_django(request):
    """Extract and validate management token from Django request"""
    auth_header = request.META.get('HTTP_AUTHORIZATION', '')
    if not auth_header or not auth_header.startswith('Bearer '):
        raise ValueError("Missing or invalid Authorization header")
    
    bearer_token = auth_header.split(' ')[1]
    logger.debug(f"Received bearer token (first 20 chars): {bearer_token[:20]}...")
    
    # SDK config from env
    domain = os.getenv("KINDE_HOST", "https://app.kinde.com")
    if domain.startswith(('http://', 'https://')):
        domain = domain.split('://', 1)[1]
    
    client_id = os.getenv("KINDE_MANAGEMENT_CLIENT_ID")
    client_secret = os.getenv("KINDE_MANAGEMENT_CLIENT_SECRET")
    
    if not all([domain, client_id, client_secret]):
        raise ValueError("Missing Kinde management credentials in environment")
    
    try:
        token_manager = ManagementTokenManager(
            domain=domain,
            client_id=client_id,
            client_secret=client_secret
        )
        
        introspection_result = token_manager.validate_and_set_via_introspection(bearer_token)
        logger.debug(f"Introspection result: {introspection_result}")
        
        access_token = token_manager.get_access_token()
        if not access_token:
            raise ValueError("Invalid management token after introspection")
        
        return token_manager
    
    except Exception as e:
        logger.error(f"Token validation failed: {str(e)}")
        raise ValueError(f"Token introspection failed: {str(e)}")

def require_m2m_auth_django(view_func):
    """Decorator to require M2M authentication for Django views"""
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        try:
            token_manager = get_management_token_django(request)
            # Store token_manager in request for use in view
            request.token_manager = token_manager
            return view_func(request, *args, **kwargs)
        except ValueError as e:
            return JsonResponse({"error": str(e)}, status=401)
        except Exception as e:
            logger.error(f"Authentication error: {str(e)}")
            return JsonResponse({"error": "Authentication failed"}, status=401)
    return wrapper
```

### Django M2M API endpoints

```python
from django.views import View
from django.http import JsonResponse

@method_decorator(csrf_exempt, name='dispatch')
class UsersView(View):
    @require_m2m_auth_django
    def get(self, request):
        """Get users with M2M authentication"""
        try:
            token_manager = request.token_manager
            
            # Create ManagementClient with the token manager
            management_client = ManagementClient(
                domain=token_manager.domain,
                client_id=token_manager.client_id,
                client_secret=token_manager.client_secret
            )
            
            # Fetch users
            users_response = management_client.get_users()
            user_count = len(users_response.users) if users_response.users else 0
            
            return JsonResponse({
                "message": "Users fetched successfully",
                "user_count": user_count,
                "users": users_response.users if users_response.users else []
            })
        except Exception as e:
            logger.error(f"Error in get_users: {str(e)}")
            return JsonResponse({"error": f"Failed to fetch users: {str(e)}"}, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class OrganizationsView(View):
    @require_m2m_auth_django
    def get(self, request):
        """Get organizations with M2M authentication"""
        try:
            token_manager = request.token_manager
            
            management_client = ManagementClient(
                domain=token_manager.domain,
                client_id=token_manager.client_id,
                client_secret=token_manager.client_secret
            )
            
            orgs_response = management_client.get_organizations()
            
            return JsonResponse({
                "message": "Organizations fetched successfully",
                "organizations": orgs_response.organizations if orgs_response.organizations else []
            })
        except Exception as e:
            logger.error(f"Error in get_organizations: {str(e)}")
            return JsonResponse({"error": f"Failed to fetch organizations: {str(e)}"}, status=500)
```

### Django URL configuration

```python
# urls.py
from django.urls import path
from .views import UsersView, OrganizationsView

urlpatterns = [
    path('management/users/', UsersView.as_view(), name='users'),
    path('management/organizations/', OrganizationsView.as_view(), name='organizations'),
]
```

## Framework Comparison

| Feature | FastAPI | Flask | Django |
|---------|---------|-------|--------|
| **Dependency Injection** | Built-in with `Depends()` | Manual with decorators | Manual with decorators |
| **Request Validation** | Automatic | Manual | Manual |
| **Async Support** | Native | Requires `asyncio` | Limited |
| **Type Hints** | Full support | Optional | Limited |
| **Documentation** | Auto-generated OpenAPI | Manual | Manual |
| **Performance** | High | Medium | Medium |
| **Learning Curve** | Low | Low | Medium |

### Key Differences

1. **FastAPI**: Uses dependency injection with `Depends()` for clean, type-safe code
2. **Flask**: Uses decorators and manual request handling with more flexibility
3. **Django**: Uses class-based views with decorators, more structured approach

